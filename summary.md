# 추상

## 프로그램의 정의
> **```데이터 + 코드```**

섹션 1에서는 데이터에 대한 추상을 다뤄본다.

## 추상과 구체
### 추상
- 사물을 정확히 이해하기 위해 사물이 지닌 여러 측면 가운데 특정 면만을 **가려내** 포착.
=> 가려내는 것은 즉, 일부를 생략하고 버리는 것
=> 정보 함축, 제거

### 추상화 레벨
- 구체 <-> 추상 사이 레벨들

### 컴퓨터 과학과 추상
1bit란 존재성을 나타냄

자료형(type)은 데이터(bit) 덩어리를 어떻게 읽는가 -> 어떻게 추상화하는가?
논리연산은 데이터끼리 만나 새로운 데이터가 나온다.

고수준 언어는 추상화 레벨이 높다는 의미
=> 기계어를 사람이 알기 쉬운 언어로 추상화

낮은 추상화 레벨 -> 높은 추상화 레벨
기계어 -> 프로그래밍 언어
하드웨어 -> 운영체제 -> 애플리케이션

=> 컴퓨터 과학은 추상화 과정이 겹겹이 조화롭게 모여 만들어진 것

적절한 추상화는 복잡한 데이터와 복잡한 로직을 단순화하여 이해하기 쉽도록 돕는다.
=> 읽기 용이

하지만 잘못된 추상화는 구체화 과정에서 유추 불가.
(소위 별다줄이라 불리는 단어들을 떠올려보자. 듣는 입장에서는 모를 수 있다...)

하지만 친구들 사이에서 자주 쓰는 신조어라면 공유하는 문맥이 존재하기 때문에, 유추가 가능할 수도 있다.
=> 도메인 영역 별 추상화 기준이 다를 수 있다.

=> **적절한 추상화**란, 해당 도메인 문맥에서 중요한 핵심 개념만 남겨 표현


## 이름 짓기
이름 짓기가 추상화의 가장 큰 첫 한걸음!

### 단수와 복수를 구분
끝에 -(e)s를 붙여 어떤 데이터가 단수인지 복수인지

### 이름 줄이지 않기
줄임말은 가독성 대신 효율성을 얻기 위함...이지만 대부분 얻는 것이 좋음.

단, **관용어**처럼 이용하는 것은 존재
col, lat(위도), lon(경도) 등...
cnt 같은 경우는 강사님은 비추천

### 은어/방언 사용하지 않기
농담이나 일부 팀원만 아는 용어 금지
-> 새로운 사람이 왔을 때도 이해할 수 있어야 함

### 도메인 용어 사용하기
도메인 용어를 먼저 정의하는 과정이 필요
상점을 store이라 할지 shop이라 할지 등을 논의...!

### 좋은 코드를 보고 습득하기
비슷한 상황에서 자주 사용하는 단어, 개념 습득하기
예로, pool, candidate, threshold(한계점) 등

## 메세드와 추상화
글에서 한 문단에 주제는 반드시 하나...
메서드도 마찬가지로, 한 메서드는 하나의 기능만!

### 메서드의 이름
메서드의 이름으로 구체적인 내용을 추상화

## ★메서드 선언부★
```반환 타입 메서드명 (파라미터) {구현부}```

이 중, 메서드명과 파라미터를 합쳐 메서드 시그니쳐라고 함

### 메서드명
- 추상화된 구체를 유추가능한 적적한 의미가 담긴 이름
- 파라미터와 연결지어 더 풍부한 의미 전달 가능
- 항상 동사로 시작해야 한다는 강박은 없어도 된다. 중요한 건 질!

### 파라미터
- 파라미터의 타입, 개수, 순서를 통해 의미 전달★
- 파라미터는 외부 세계와 소통하는 창
- 요리 레시피의 재료 같은 느낌!

### 반환타입
- 메서드 시그니처에 납득이 가는 적절한 타입의 반환값 돌려주기
- void 대신 충분히 반환할 만한 값이 있는지 고민하기 
- -> 반환값이 있어야 테스트가 용이

## ★추상화 레벨★
서점에서 책을 고를 때, 책 제목을 우선적으로 보며 내용을 유추할 것이다. 만약 책이 표지도 제목도 없이 종이 뭉치로 이루어져 있다면 무슨 도서인지 파악이 불가능하다!

메서드가 추출된 외부 세걔는 추상화 레벨이 높고, 추출된 당사자인 내부 세걔는 추상화 레벨이 낮다.
외부와 내부는 메서드 이름을 통해 소통한다.

하나의 세계 안에서는, **추상화 레벨이 동등**해야 한다.

## 매직넘버, 매직스트링
- 의미는 갖고 있으나, 상수로 추출되지 않은 숫자, 문자열 등
- 상수 추출로 이름을 짓고 의미를 부여함으로써 가독성과 유지보수성을 높임

# 논리 사고의 흐름

## 뇌 메모리 적게 쓰기 
데이터를 어떻게 요리할까? 어떤 사고와 논리를 갖고 코드를 짜는가?

인지적 경계성 - 최소한의 인지로 최고 효율의 경제성을 갖자!
인간의 뇌는 멀티태스킹이 불가능! 한 블록 내에 너무 복잡한 코드는 이해가 어려움...
=> 뇌 메모리를 적게 쓸 수 있는 방향으로 코드를 작성하자.

## Early return
일찍 리턴할 수 있는 것은 빠르게 리턴하자! 이를 통해 if문의 else 사용을 지양한다.
방식: if 문단을 메서드로 추출 후, 조건을 충족할 경우 구문 실행 후 바로 return 시키기

## 사고의 depth 줄이기
- 중첩 분기문, 중첩 반복문 줄이기
  - 각각의 반복문을 메서드로 쪼개보자! 외부 세걔의 일은 내부 세계에서 일어나는 일에 간섭할 수 없도록
  - ★무조건 뎁스를 1로 만들자는 의미가 아니다! 추상화를 통한 사고 과정의 뎁스를 줄이는 것이 중요
  - 2중 중첩 상태가 더 도움이 된다고 판단되면 메서드 분리는 금물. 선택은 본인이...
- 사용할 변수는 가깝게 선언하기
  - i = 10; j = i + 10; 이라는 각각의 코드가 너무 멀면, i의 값이 기억이 안 날 수 있다!
  - 바로 사용할 거는 가깝게 붙여 사용한다!
- 메서드를 리팩토링할 때 컴파일 에러가 나지 않도록 주의!
- 리팩토링할 메서드를 복제해서 리팩토링 완료 후 원 메서드를 지우는 방향성으로...

## 공백 라인을 대하는 자세
- 공백도 의미를 가진다.

## 부정어를 대하는 자세
- 부정어구를 쓰지 않아도 되는 상황인지 체크
- 부정의 의미를 담은 다른 단어가 존재하는지 고민하기
- ! 같은 부정 연산자는 가독성이 떨어짐. 지양하자!

## 해피 케이스와 예외 처리
- 사람은 해피 케이스에 몰두하기 마련. 누구나 그렇다!
- 예외가 발생할 가능성 낮추기
- 검증이 필요한 부분은 주로 외부 세걔와의 접점
  - 사용자 입력, 객체 생성자, 외부 서버 요청 등...
- 의도한 예외와 예상하지 못한 예외를 구분
  - 사용자에게 보여줄 예외 vs 개발자가 보고 처리해야 하는 예외

### Null을 대하는 자세
- 자바에서는 null 처리가 중요...(NullPointException 발생 경우가 너무 많음)
  - NullPoint를 최대한 방지하도록 경각심 가지기
  - 메서드 설계 시 return null을 자제
  - 어려우면 Optional 사용을 고려
    - 단, Optional은 비싼 객체. 꼭 필요할 때만 사용
    - Optional을 파라미터로 받지 않도록 하기. 분기 케이스가 3개나 된다.
    - Optional 반환 시 빠르게 해소.
      - isPresent() 대신 get() 대신 API를 사용한다. (isPresent()는 분기문을 생성한다.)
      - orElseGet(), orElseThrow(), ifPresent(), ifPresentOrElse() 등을 사용하자.
      - ★orElse, orElseGet, orElseThrow 각각의 차이를 구분하자.★
        - orElseThrow는 값이 있으면 쓰고 없으면 예외.
        - orElse()는 괄호 안이 항상 실행되는 값이다. 확정된 값일 때만 사용한다. (호출할 필요가 없어도(null이어도...) 항상 실행)
        - orElseGet()은 null인 경우 실행된다. 값을 제공하는 동작을 정의한다. (null인 경우에만 괄호 안 동작이 실행)
          - orElseGet()은 Supplier를 통해 람다식 형태로 매개변수를 전달한다. 이는 자바의 람다식 동작 방식으로 인해, 즉시 실행하지 않고 호출할 때만 실행한다. 이를 통해 orElse와 다르게 지연 평가가 가능

### 현재 지뢰 게임의 문제
1. 범위를 벗어난 좌표 입력 시 ArrayIndexOutOfBoundsException 발생
2. 깃발은 꽂은 자리에 다시 깃발을 꽂는 행위를 할 경우, 별도의 안내 혹은 깃발제거가 없음
3. 깃발을 꽂은 자리에 오픈을 해도 별도의 안내가 없고 오픈이 안 됨
4. 이미 오픈 한 자리를 다시 오픈하려고 할 시 무반응(의도 스펙일 수 있음)

### 안티패턴?
- e.printStackTrace()을 지우시면서, 지나가듯 말씀하신 내용.
- 안티 패턴에 대해 공부하기
  - 신 객체 혹은 신 클래스(God Object/God Class): 객체가 너무 많은 기능과 책임을 가짐
    - SOLID 학습을 하면 왜 문제인지 쉽게 캐치할 수 있을 것 같다.
  - 스파게티 코드
    - 개발 공부를 하는 사람이라면 한 번쯤은 무조건 들었을 거라 생각한다.
  - 매직 넘버
    - 지뢰게임 예제에서 보드의 사이즈 크기만큼 반복을 돌릴 때, 상수로 바꾸는 리팩토링 했던 내용을 복기해보자.
  - 복붙
    - 중복 코드로 인한 폐해는 쉽게 알 수 있을 것
  - 싱글톤 남용
  - 설정을 하드코딩
  - 부적절한 예외처리
  - e.printStackTrace() 메서드 사용
    - 로그 관리가 어려움. 프로그램이 실행되는 콘솔에만 출력되어 관리 시스템에 기록되지 않음
    - 추적의 어려움
    - 원인, 발생 위치 파악 어려움
    - 유지보수 저하
    - 성능 이슈

# 객체 지향 패러다임

## 추상의 관점으로 보는 객체 지향

### 절차 지향 vs 객체 지향 vs 함수형
자바는 당연 **객체 지향**

### 객체
- 추상화된 데이터 + 코드
- 객체 간의 **협력**과 객체가 담당하는 **책임**
- 캡슐화 / 추상화 / 상속 / 다형성

- **"관심사의 분리"**에 따라 관리
=> 높은 응집도, 낮은 결합도

## 객체 설계하기

### 추상화 레벨
- 외부 세계와 내부 세계와의 분리(소통은 공개 메서드로)

- 객체의 비공개 필드와 비공개 로직은 공개 메서드 선언부로 외부와 소통
- **객체의 책임**은 **공개 메서드**로 인해 드러난다
- 책임에 따라 분리된 각 객체들이 상호작용을 하며 상호 협력을 한다.
- 절차 지향에서 보이지 않던 것을 가시화
- 관심사가 한 군데로 모여 유지보수성이 높음
- 여러 객체를 사용하는 입장에서는 구체적 구현에 신경쓰지 않고 보다 높은 추상화 레벨에서 도메인 다룸

### 새로운 객체 생성 시 주의점
- 1개의 관심사가 명확하게 책임이 정의되었는가?
  - 외부와 어떤 소통을 하려는 건지 고민해보자.
- 생성자, 정적 팩토리 메서드에서 유효성 검증 가능
  - 도메인 특화 검증 로직이 들어갈 수 있음(데이터의 유효성 검증 등...)
- setter 사용 자제
  - 데이터는 불변이 최고! => 사이드 이펙트가 없음
  - 객체 내부에서 외부 세계의 개입 없이 자체 변경 및 가공을 하도록...
  - 데이터 변경이 불가피할 경우 set~ 보다는 **update~** 처럼 의미있는 네이밍 고려
- getter 사용 자제
  - 반드시 필요한 경우에 추가
  - **객체에 메세지를 보내라!**
- 필드 수는 적을 수록 GOOD
  - 불필요 데이터가 많을수록 복잡도 높아짐
  - 중복 데이터 필드는 최대한 줄이기 => 파생 데이터 필드는 메서드로 풀어보기
    - 단, 미리 가공하는 것이 성능 이점이 있다면? 필드가 더 좋음.

### 새로운 도메인 지식을 얻다...!
- 열렸다/닫혔다 개념과 사용자가 체크했다는 개념은 다름...
- 도메인 지식은 만드는 것이 아닌 **발견하는 것**


## SOLID
로버트 마틴의 솔리드...

### SRP(Single Responsibility) / 단일 책임 원칙
  - 한 객체가 책임 1, 책임 2를 모두 갖고 있다면, SRP를 위반
  - 하나의 클래스는 단 한 가지의 변경 이유(= 책임) 만을 가져야 한다.
  - 객체가 가진 공개 메서드, 필드, 상수 등은 해당 객체의 단일 책임에 의해서만 변경 되는가?
  - 관심사의 분리
  - 높은 응집도(클래스나 모듈 내 요소들이 긴밀하게 작용), 낮은 결합도(=의존성 / 한 객체가 변경되었을 때 다른 객체가 변화되는가)

  - 클래스와 객체 레벨에서 강조되는 원칙
  - 책임을 갖는다의 의미? 지금 객체의 책임은? <- 책임이란 판단이 어려움!
  - 책임을 볼 줄 아는 눈이 필요 

### OCP(Open-Closed)
  - 확장에는 열려 있고 수정에는 닫혀 있기
  - 기존 코드 변경 없이, 시스템 기능 확장해야함
  - 추상화와 다형성을 활용

  - 지뢰 찾기에 게임 난이도 라는 요구사항이 발생했다고 가정

### LSP(Liskov Substitution)
  - 상속 구조에서, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환 가능해야 한다.
  - 자식 클래스는 부모 클래스의 책임을 준수하고 부모 클래스의 행동을 변경하면 안됨
  - LSP 위반 시 상속 클래스 사용 시 오동작, 예상 밖 예외 발생

### ISP(Interface Segregation)
  - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안됨
  - 인터페이스 잘게 쪼개기!!
  - ISP 위반 시 불필요한 의존성으로 인해 결합도가 높아짐
  - 인터페이스에 A,B 기능이 존재하고, 구현체 1은 A,B를 모두 사용하고 구현체 2가 A만 사용한다면
  - 인터페이스를 A, B로 쪼개야 한다.

### DIP(Dependency Inversion)
  - 상위 수준의 모듈은 하위 수준의 모듈에 의존하면 안 됨
  - 둘 모두 추상화에 의존(=의존성의 역방향)해야 함
  - 고수준 모듈이 저수준 모듈을 참조하는 것을 의존성의 순방향이라고 한다.
  - 저수준 모듈 변경 시에도 고수준 모듈에 영향이 가면 안된다.

  - 카페(고수준)에서 커피(저수준)를 판다(sell 함수)라는 행위를 함
    - 카페에서 다른 음료를 판매하고 싶다면?
    - 음료라는 인터페이스를 두기...